import pydot

from ..utils.logger import logger
from .powers import Powers


class Dot(Powers):
    """Generate dot for set of powers"""

    def __init__(
        self,
        input_files: list = "04_Powers_SAMPLE.yaml",
        dependencies: list = None,
        add_loners: bool = True,
    ):
        """Initialize Dot class

        Args:
            input_files (str, optional): Relative path string or list of strings.
                Defaults to "04_Powers_SAMPLE.yaml".
            dependencies (list, optional): List of dependencies to include. Defaults to
                None, meaning all: ["Power", "Skill", "Level", "Role"]
            add_loners (bool, optional): Include items without dependent powers.
                Defaults to True.

        Additional Attributes:
            _template (str):
            _dotstring (str):
            _graph (str):
            _loners (list): list of loners
        """
        super().__init__(input_files=input_files)
        if not dependencies:
            self._dependencies = [
                f"Prereq_{dep}" for dep in ["Power", "Skill", "Level", "Role"]
            ]
        else:
            self._dependencies = [f"Prereq_{dep}" for dep in dependencies]
        self._template = None
        self._add_loners = add_loners
        self._dotstring = None
        self._graph = None
        self._loners = []

    def quote(self, s):
        """Return input as quoted string"""
        s = str(s) if not isinstance(s, str) else s
        return '"{}"'.format(s.replace('"', '\\"'))

    def edge_str(self, a: str, b: str = None):
        """Generates a `->` b notation for dot edges

        Args:
            a (str): first node
            b (str, optional): Second node. Optionally with comparison e.g., STR > 2
        """
        comparators = ["<", ">", "≤", "≥"]
        if b is not None:
            label = ""
            if any(comp in b for comp in comparators):
                b, comparison = b.split(" ", 1)
                label = f' [label="{comparison}"]'
            return f"{self.quote(b)} -> {self.quote(a)}{label}"
        else:
            return f"{self.quote(a)}"

    def get_edges(self, name, children=[]):
        """Generate full set of child->node given children"""
        edges = []
        edges.append(self.edge_str(name))  # Add name to list
        for c in children:  # For each child
            if isinstance(c, str):
                edges.append(self.edge_str(name, c))  # make node->child string as edge
            elif isinstance(c, dict):  # if child is dict
                key = c.keys()[0]  # get first key
                edges.append(self.edge_str(name, key))  # make node->key string
                # get edges recursively with key and value from key
                edges = edges + self.get_edges(key, c[key])
        return edges

    @property
    def loners(self):
        """Loners list, generated by dotstring func. Not implemented"""
        if self._add_loners and not self._loners:
            self.dotstring  # need to run to get all children then add/remove loners
            # TODO: gen list of loners
            logger.WARN("Get loners list not implemented")
        return self._loners

    @property
    def template(self) -> str:
        """All dot file frontmatter"""
        if not self._template:
            gen_powers = True if "powers" in self._stem.lower() else False

            dot_frontmatter = (
                """digraph {concentrate=true; splines=curved; compound=true;\n"""
            )
            dot_subgraph_role = (
                "\n/* Roles */\n"
                "\tCaster [shape=box style=filled];\n"
                "\tSupport [shape=box style=filled];\n"
                "\tMartial [shape=box style=filled];\n"
                "\tDefender [shape=box style=filled];\n"
            )
            dot_subgraph_skill = (
                "/* Skill */\n"
                '\tsubgraph cluster_stats { label="Stats/Attributes"\n'
                '\t\tsubgraph cluster_Agility{label="Agility" {Finesse Stealth} };\n'
                '\t\tsubgraph cluster_Conviction{label="Conviction" {Bluffing Performance} };\n'
                '\t\tsubgraph cluster_Intuition{label="Intuition" {Detection Craft} };\n'
                '\t\tsubgraph cluster_Intelligence{label="Intelligence"'
                "{Knowledge Investigation} };\n"
                '\t\tsubgraph cluster_Strength{label="Strength"  {Athletics Brute} };\n'
                '\t\tsubgraph cluster_Vitality{label="Vitality" {Vitality [style = invis]} };'
                "\n\t}\n\n"
            )
            dot_subgraph_level = (
                "/* Level */\n"
                '\tsubgraph cluster_levels { label="Levels";\n'
                "\tLevel_1 [shape=box style=filled];\n"
                "\tLevel_2 [shape=box style=filled];\n"
                "\tLevel_3 [shape=box style=filled];\n"
                "\tLevel_4 [shape=box style=filled];}\n\n"
            )
            dot_subgraph_loners = (
                "/* Loners */\n"
                '\tsubgraph cluster_levels {label="No Prerequisites";\n\t%s}\n'
            )
            if gen_powers:
                if "Prereq_Role" in self._dependencies:
                    dot_frontmatter += dot_subgraph_role
                if "Prereq_Skill" in self._dependencies:
                    dot_frontmatter += dot_subgraph_skill
                if "Prereq_Level" in self._dependencies:
                    dot_frontmatter += dot_subgraph_level
            if self._add_loners:
                dot_frontmatter += dot_subgraph_loners % ";\n\t".join(self.loners)
            return dot_frontmatter + "\n/* Linked */\n\t" + "%s\n}"
        return self._template

    def get_children(self, power_dict):
        """Return child nodes based on dependency list"""
        if "Prereq_Level" in power_dict.keys():
            power_dict["Prereq_Level"] = f"Level_{power_dict['Prereq_Level']}"
        children = [  # returns embedded lists
            self.or_to_list(v) for k, v in power_dict.items() if k in self._dependencies
        ]
        return [item for sublist in children for item in sublist]

    @property
    def dotstring(self):
        """Dot file contents"""
        if not self._dotstring:
            edges = []
            for power_name, power in self.content.items():  # for each power
                power_node = self.get_edges(power_name)  # Get `->` notation for power
                children = self.get_children(power)  # Get power children
                if self._add_loners or children:  # If keep loners or has children
                    edges += self.get_edges(power_name, children)  # `->` for children
                    try:  # b/c children, not loner. try to remove from loner list
                        self._loners.remove(power_node)
                    except ValueError:  # if not in loner list, ValueError ok
                        pass
                if not children:  # If no children, is loner
                    self._loners += power_node
            # write list of `->` notations, on new indented lines
            self._dotstring = self.template % ";\n\t".join(edges)
        return self._dotstring

    @property
    def graph(self):
        """Make pydot graph format from dotstring"""
        if not self._graph:
            self._graph = pydot.graph_from_dot_data(self.dotstring)[0]
        return self._graph

    def write(self, output_fp=None):
        """Write dot file"""
        if not output_fp:
            output_fp = self.filepath_default_output + self._stem + ".dot"
        with open(output_fp, "w", newline="") as f_output:
            f_output.write(self.dotstring)
        logger.info("Wrote dot")

    def to_pic(self, output_fp=None, out_format=["png", "svg"]):
        """Write graph as pic. png and/or svg. output_fp is one string, no suffix

        Args:
            output_fp (str): Relative output filepath. Default none, meaning local
                _output/ folder
            out_format (list): List of formats or string. png and/or svg
        """
        if not output_fp:
            output_fp = self.filepath_default_output + self._stem
        out_format = self.ensure_list(out_format)
        if "png" in out_format:
            try:
                self.graph.write_png(output_fp + ".png", prog="dot.exe")
            except FileNotFoundError:
                self.graph.write_png(output_fp + ".png")
            logger.info("Wrote png")
        if "svg" in out_format:
            self.graph.write_svg(output_fp + ".svg")
            logger.info("Wrote svg")
